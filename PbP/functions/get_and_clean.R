require(magrittr)
getPbPData <- function(ESPNPbP, gameId) {
    # given a gameId and the ESPN PbP url pattern (constant), return
    # un-processed PbP data -- currently returns as a data frame, 
    # converting the HTML table
    if (require(XML) & require(RCurl)) {
        PbPURL <- sub("__GAMEID__", gameId, ESPNPbP)
        PbP <- readHTMLTable(PbPURL, stringsAsFactors=FALSE)
        
        # it's a bit of a hack to assume that this will always work
        return(PbP[[length(PbP)]])
    }
}



getShotData <- function(ESPNShot, gameId) {
    # given a gameId and the ESPN shot location url pattern (constant), return
    # shot location data from XML as a list
    if (require(XML) & require(RCurl) & require(magrittr)) {
        shotURL <- paste(ESPNShot, gameId, sep="")
        parsed_shots <- getURL(shotURL) %>%
            xmlParse() %>%
            xmlToList()
        
        names(parsed_shots) <- sapply(parsed_shots, function(x) x["id"])
        do.call("rbind", parsed_shots) %>% 
            data.frame(stringsAsFactors=FALSE)
    }
}

parseShotDesc <- function(shotDesc) {
    # parses a vector of shot descriptions, returns useful data in a list,
    # each element of the list is a vector of which x[2:end] house the useful data
    regmatches(shotDesc, 
               regexec("(Made|Miss)\\s([0-9]{1,2})ft\\s[^\\s]+\\s([0-9]{1,2}):([0-9]{2})", 
                       shotDesc))
}

cleanShotData <- function(df) {
    # workhorse to clean the shot location data. takes an object generated by getShotData
    # and returns a data frame with parsed shot location data. 
    
    # type conversions -- this is probably hella ineffecient. can these be specified when i
    # first grab the data?
    df$x <- as.integer(df$x)
    df$y <- as.integer(df$y)
    df$qtr <- as.integer(df$qtr)
    df$t <- as.factor(df$t)
    df$made <- as.logical(df$made)
    
    # x,y positions on the court. ESPN uses a full (94ft) court with the home team going from 
    # 48-94 and the away team from 0-47. meanwhile, since they're on opposite sides of the court, 
    # the left and right are reversed for one end of the court. 
    # conversion puts all data into the same halfcourt coordinate system
    df$y_adj <- ifelse(df$t=="h", 94-df$y, df$y)
    df$x_adj <- ifelse(df$t=="h", 50-df$x, df$x)
    
    # parse shot description and create new columns for the data
    parsed_desc <- parseShotDesc(df$d)
    df$made_basket <- sapply(parsed_desc, function(x) x[2]) == "Made"
    df$dist <- as.integer(sapply(parsed_desc, function(x) x[3]))
    df$min <- as.integer(sapply(parsed_desc, function(x) x[4]))
    df$sec <- as.integer(sapply(parsed_desc, function(x) x[5]))
    
    # convert times to seconds remaining -- should this be fractions of seconds? could 
    # multiply by 10 to keep integer values even if the data expands to include 
    # tenths of a second.
    df$time <- df$min*60 + df$sec
    
    return(df)
}

getQuarterIndexes <- function(col) {
    finder <- "([0-9](st|nd|rd|th) (Quarter|Overtime))"
    QI <- rep(as.character(NA), length(col))
    QI[grep(finder, col)] <- regmatches(col, regexpr(finder, col))  
    return(QI)
}

fillSpaces <- function(val) {
    if (!is.na(val[1])) {
        for (i in 1:length(val)) {
            if (is.na(val[i])) val[i] <- val[i-1]
        }
    }
    return(val)
}

cleanPbP <- function(PbP) {
    names(PbP) <- c("time", "away", "score", "home")
    PbP$period <- getQuarterIndexes(PbP[,1])
    PbP$period <- fillSpaces(PbP$period)
    PbP <- PbP[grep(":", PbP$time),]
    rownames(PbP) <- seq(nrow(PbP))
    times <- do.call(rbind, strsplit(PbP$time, ":"))
    PbP$seconds_left <- (as.integer(times[,1]) *60) + as.integer(times[,2])  
    PbP$team <- ifelse(PbP[,2]=="?", "home", "away")
    PbP$play_desc <- ifelse(PbP[,2]=="?", PbP[,4], PbP[,2])
    PbP$play <- playType(PbP$play_desc)
    return(PbP)
}

playType <- function(playDesc) {
    playDesc <- gsub("\\s{1,}", " ", playDesc)
    play <- rep(as.character(NA), length(playDesc))
    play[grepl("(makes|misses)", playDesc, ignore.case=TRUE)] <- "shot"
    play[grepl("free throw", playDesc, ignore.case=TRUE)] <- "free throw"  
    play[grepl("timeout", playDesc, ignore.case=TRUE)] <- "timeout"
    play[grepl("rebound", playDesc, ignore.case=TRUE)] <- "rebound"  
    play[grepl("enters the game", playDesc, ignore.case=TRUE)] <- "substitution"  
    return(play)
}
