get_pbp <- function(pbp, game_id) {
    # given a game_id and the ESPN PbP url pattern (constant), return
    # un-processed PbP data
    if (require(XML) && require(RCurl)) {
        pbp_url <- sub("__GAMEID__", game_id, pbp)
        pbp <- readHTMLTable(pbp_url, stringsAsFactors=FALSE, encoding = "UTF-8")
        
        res <- pbp[[length(pbp)]]
        attr(res, "summary") <- pbp[[length(pbp)-1]]
        attr(res, "game_id") <- game_id
        
        return(res)
    }
}



get_shots <- function(shot, game_id) {
    # given a game_id and the ESPN shot location url pattern (constant), return
    # raw shot location data
    if (!require(XML)) {
        stop("please install package xml")
    }
    
    if (!require(RCurl)) {
        stop("please install package rcurl")
    }
    
    if (!require(magrittr)) {
        stop("please install package magrittr")
    }
    
    shot_url <- paste(shot, game_id, sep="")
    parsed_shots <- getURL(shot_url) %>%
        xmlParse() %>%
        xmlToList()
    
    names(parsed_shots) <- sapply(parsed_shots, function(x) x["id"])
    do.call("rbind", parsed_shots) %>%
        data.frame(stringsAsFactors = FALSE)
}

parse_shot_desc <- function(shot_desc) {
    # parses a vector of shot descriptions, returns useful data in a list,
    # each element of the list is a vector of which x[2:end] house the useful data
    regmatches(shot_desc, 
               regexec("(Made|Miss)\\s([0-9]{1,2})ft\\s[^\\s]+\\s([0-9]{1,2}):([0-9]{2})", 
                       shot_desc))
}

clean_shots <- function(df) {
    # workhorse to clean the shot location data. takes an object generated by getShotData
    # and returns a data frame with parsed shot location data. 
    
    # type conversions -- this is probably hella ineffecient. can these be specified when i
    # first grab the data?
    df$x <- as.integer(df$x)
    df$y <- as.integer(df$y)
    df$qtr <- as.integer(df$qtr)
    df$t <- as.factor(df$t)
    df$made <- as.logical(df$made)
    
    # x,y positions on the court. ESPN uses a full (94ft) court with the home team going from 
    # 48-94 and the away team from 0-47. meanwhile, since they're on opposite sides of the court, 
    # the left and right are reversed for one end of the court. 
    # conversion puts all data into the same halfcourt coordinate system
    df$y_adj <- ifelse(df$t=="h", 94-df$y, df$y)
    df$x_adj <- ifelse(df$t=="h", 50-df$x, df$x)
    
    # parse shot description and create new columns for the data
    parsed_desc <- parse_shot_desc(df$d)
    df$made_basket <- sapply(parsed_desc, function(x) x[2]) == "Made"
    df$dist <- as.integer(sapply(parsed_desc, function(x) x[3]))
    df$min <- as.integer(sapply(parsed_desc, function(x) x[4]))
    df$sec <- as.integer(sapply(parsed_desc, function(x) x[5]))
    
    # convert times to seconds remaining -- should this be fractions of seconds? could 
    # multiply by 10 to keep integer values even if the data expands to include 
    # tenths of a second.
    df$time <- df$min*60 + df$sec
    
    return(df)
}

get_quarter <- function(col) {
    finder <- "([0-9](st|nd|rd|th) (Quarter|Overtime))"
    quarter <- rep(as.character(NA), length(col))
    quarter[grep(finder, col)] <- regmatches(col, regexpr(finder, col))  
    return(quarter)
}

fill_spaces <- function(val) {
    if (!is.na(val[1])) {
        for (i in 1:length(val)) {
            if (is.na(val[i])) val[i] <- val[i-1]
        }
    }
    return(val)
}

clean_pbp <- function(pbp) {
    
    if (!require(magrittr)) {
        stop("please install magrittr")
    }
    
    game_id <- attr(pbp, "game_id")
    names(pbp) <- c("time", "away", "score", "home")
    
    # add column for what quarter it is
    pbp$period <- get_quarter(pbp[,1]) %>% 
        fill_spaces()
    
    # eliminate rows that aren't part of the PbP
    pbp <- pbp[grep(":", pbp$time),]
    pbp <- pbp[!is.na(pbp$score),]
    
    #artificial record numbering system.
    rownames(pbp) <- paste(game_id, formatC(seq(nrow(pbp)), width=4, flag="0"), sep="")
    
    # convert time from mm:ss to total seconds remaining
    times <- do.call(rbind, strsplit(pbp$time, ":"))
    pbp$seconds_left <- (as.integer(times[,1]) *60) + as.integer(times[,2])  
    
    # create a single column for all plays, with a separate home/away id
    pbp$team <- ifelse(pbp[,2]=="", "home", "away")
    pbp$play_desc <- ifelse(pbp[,2]=="", pbp[,4], pbp[,2])
    
    # determine the general play type in each line, and then dispatch
    # appropriate parsing functions to return the details about the play
    
    # 1) playType
    pbp$play_type <- play_type(pbp$play_desc)
    
    # 2) parse plays, using appropriate function based on play type
    return(pbp)
}

play_type <- function(play_desc) {
    play_desc <- gsub("\\s{1,}", " ", play_desc)
    play_desc <- gsub("<.+> ", "", play_desc)
    
    
    # this part needs to be cleaned up, too much repetition
    play <- rep(as.character(NA), length(play_desc))
    play[grepl("(makes|misses)", play_desc, ignore.case=TRUE)] <- "shot"
    play[grepl("free throw", play_desc, ignore.case=TRUE)] <- "free throw"  
    play[grepl("timeout", play_desc, ignore.case=TRUE)] <- "timeout"
    play[grepl("rebound", play_desc, ignore.case=TRUE)] <- "rebound"  
    play[grepl("enters the game", play_desc, ignore.case=TRUE)] <- "substitution"  
    play[grepl("\\b(foul)\\b", play_desc, ignore.case=TRUE)] <- "foul"
    play[grepl("\\b(traveling)\\b", play_desc, ignore.case=TRUE)] <- "traveling"
    play[grepl("\\b(bad pass)\\b", play_desc, ignore.case=TRUE)] <- "bad pass"
    play[grepl("\\b(lost ball)\\b", play_desc, ignore.case=TRUE)] <- "lost ball"
    play[grepl("\\b(turnover)\\b", play_desc, ignore.case=TRUE)] <- "turnover"
    play[grepl("\\b(blocks)\\b", play_desc, ignore.case=TRUE)] <- "blocked shot"
    play[grepl("shot clock", play_desc, ignore.case=TRUE)] <- "shot clock violation"
    play[grepl("delay of game", play_desc, ignore.case=TRUE)] <- "delay of game"
    play[grepl("\\b(kicked ball)\\b", play_desc, ignore.case=TRUE)] <- "kicked ball"
    play[grepl("\\s(vs.)\\s", play_desc, ignore.case=TRUE)] <- "jump ball"
    play[grepl("^End", play_desc, ignore.case=TRUE) | grepl("^Start", play_desc, ignore.case=TRUE)] <- "buzzer"
    play[grepl("\\b(turnover)\\b", play_desc, ignore.case=TRUE)] <- "turnover"
    play[grepl("\\b(blocks)\\b", play_desc, ignore.case=TRUE)] <- "blocked shot"
    play[grepl("\\b(kicked ball)\\b", play_desc, ignore.case=TRUE)] <- "kicked ball"
    play[grepl("\\s(vs.)\\s", play_desc, ignore.case=TRUE)] <- "jump ball"
    play[grepl("^End of", play_desc, ignore.case=TRUE)] <- "buzzer"
    return(play)
}
